local build = {}

-- using postmake require and not built in require because we are using go:embed and not a real file
local util = postmake.require("./util.lua")
local makecodesecion = postmake.require("./secions/code.lua")

-- Theres more but I wil add them when I Need them.
local DefaultInnoSettinsList =
{
	DisableDirPage = "yes",
	DisableProgramGroupPage = "yes",
	Compression = "lzma",
	SolidCompression = "yes",
	WizardStyle = "modern",
	PrivilegesRequired = "lowest"
}
local OptionalInnoSettinsList =
{
	"SetupIconFile",
	"WizardStyle"
}
local ContextBasedDefaultsSettinsList =
{
	"DefaultGroupName",
	"OutputBaseFilename",
	"AppId",
	"LaunchProgram",
	"MyAppExeName",
	"MyAppName",
	"MyAppVersion",
	"MyAppPublish",
	"MyAppURL",
	"MyAppExeName"
}
local Othersettings = {
	"proxy"
}

function build.make(postmake, configs, settings)
	--- Boring checks
	if #configs ~= 1 then
		print("innoSetup only allows one windows config." .. #configs .. " was given")
		os.exit(1)
	end

	local config = configs[1]

	if config == nil then
		print("config is nil")
		os.exit(1)
	end

	if config.os() ~= "windows" then
		print("config os is not windows innoSetup only allows to .iss make for windows")
		os.exit(1)
	end

	if settings.AppId == nil then
		print("Set the Missing AppId varable on the settings object")
		os.exit(1)
	end

	--- checking settings

	local goterrorinsettings = false
	for key, _ in pairs(settings) do
		local issettingallowed = false

		for Defaultkey, _ in pairs(DefaultInnoSettinsList) do
			if key == Defaultkey then
				issettingallowed = true
				break
			end
		end

		if issettingallowed then
			goto continue
		end

		for _, SettingName in ipairs(OptionalInnoSettinsList) do
			if key == SettingName then
				issettingallowed = true
				break
			end
		end

		if issettingallowed then
			goto continue
		end


		for _, SettingName in ipairs(ContextBasedDefaultsSettinsList) do
			if key == SettingName then
				issettingallowed = true
				break
			end
		end

		if issettingallowed then
			goto continue
		end

		for _, SettingName in ipairs(Othersettings) do
			if key == SettingName then
				issettingallowed = true
				break
			end
		end
		if issettingallowed then
			goto continue
		end

		print("The Key '" .. key .. "' is not an  valid inno Settins. Typo?")
		goterrorinsettings = true
		::continue::
	end

	if goterrorinsettings then
		print(
			"\nCheck the Inno Setup Docs https://jrsoftware.org/ishelp/index.php?topic=iconssection\nif The setting exist help add it on https://github.com/LostbBlizzard/postmake\n\n")
		os.exit(1)
	end


	if settings.proxy then
		if settings.proxy.uninstallcmd == nil then
			print("proxy setting is missing the uninstallcmd field")
		end
		if settings.proxy.program == nil then
			print("proxy setting is missing the program field")
		end
		if settings.proxy.path == nil then
			print("proxy setting is missing the path field")
		end

		if settings.proxy.uninstallcmd == nil or settings.proxy.program == nil then
			os.exit(1)
		end
	end
	--- end of boring checks

	--- InnoSettings with context based Defaults
	local Inno_DefaultGroupName = util.UseOrDefault(settings.DefaultGroupName, postmake.appname())
	local Inno_OutputBaseFilename = util.UseOrDefault(settings.OutputBaseFilename, postmake.appname() .. "Setup")
	---Other Settings

	---
	print("---building inno script")

	local outputpath = "./" .. postmake.output() .. ".iss"

	print("writing install file to " .. outputpath)

	local outputfile = io.open(outputpath, "w")
	if outputfile == nil then
		print("unable to open file '" .. outputpath .. "'")
		os.exit(1)
	end

	outputfile:write("; Script generated by the PostMake InnoSetup Plugin.\n")
	outputfile:write(
		"; When using PostMake InnoSetup you can add or override any of value below. By adding values to the setings table Ex\n")
	outputfile:write(
		"; postmake.make(innosetup, { windows_64 }, { OutputBaseFilename = \"coolbasefile\", DefaultGroupName = \"test\" });\n\n")


	outputfile:write("#define MyAppName \"" .. util.UseOrDefault(postmake.MyAppVersion, postmake.appname()) .. "\"\n")
	outputfile:write("#define MyAppVersion \"" ..
		util.UseOrDefault(postmake.MyAppVersion, postmake.appversion()) .. "\"\n")
	outputfile:write("#define MyAppPublisher \"" ..
		util.UseOrDefault(postmake.MyAppPublisher, postmake.apppublisher()) .. "\"\n")
	outputfile:write("#define MyAppURL \"" .. util.UseOrDefault(settings.MyAppURL, postmake.appwebsite()) .. "\"\n")
	outputfile:write("#define MyAppExeName \"" ..
		util.UseOrDefault(settings.MyAppExeName, postmake.appname() .. ".exe") .. "\"\n\n")

	outputfile:write("[Setup]\n")
	outputfile:write(
		"; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.\n")
	outputfile:write("; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)\n")


	outputfile:write("AppId={{" .. settings.AppId .. "}\n")
	outputfile:write("AppName={#MyAppName}\n")
	outputfile:write("AppVersion={#MyAppVersion}\n")
	outputfile:write("AppVerName={#MyAppName} {#MyAppVersion}\n")
	outputfile:write("AppPublisher={#MyAppPublisher}\n")
	outputfile:write("AppPublisherURL={#MyAppURL}\n")
	outputfile:write("AppSupportURL={#MyAppURL}\n")
	outputfile:write("AppUpdatesURL={#MyAppURL}\n")

	outputfile:write("DefaultDirName=" .. util.postmakepathtoinnopath(postmake.appinstalldir()) .. "\n")
	outputfile:write("DefaultGroupName=" .. Inno_DefaultGroupName .. "\n")

	if postmake.applicensefile() == nil then
		outputfile:write("LicenseFile= \"" .. postmake.applicensefile() .. "\"\n")
	end

	outputfile:write("OutputBaseFilename=" .. Inno_OutputBaseFilename .. "\n")


	local hasaddeddefault = false
	for key, value in pairs(settings) do
		for SettingName, _ in pairs(DefaultInnoSettinsList) do
			if key == SettingName then
				if hasaddeddefault == false then
					outputfile:write("; Boring Default Settings \n")
				end
				outputfile:write(key .. "=" .. value .. "\n")
				hasaddeddefault = true
				break
			end
		end
	end

	for SettingName, Value in pairs(DefaultInnoSettinsList) do
		local hassetting = false
		for key, _ in pairs(settings) do
			if key == SettingName then
				hassetting = true
				break
			end
		end
		if not hassetting then
			if hasaddeddefault == false then
				outputfile:write("; Boring Default Settings \n")
			end
			outputfile:write(SettingName .. "=" .. Value .. "\n")
			hasaddeddefault = true
		end
	end
	local hasaddedoptional = false
	for key, value in pairs(settings) do
		for _, SettingName in ipairs(OptionalInnoSettinsList) do
			if key == SettingName then
				if hasaddedoptional == false then
					outputfile:write("; Boring Optional Settins \n")
				end
				outputfile:write(key .. "=" .. value .. "\n")
				break
			end
		end
	end


	outputfile:write("\n[Languages]\n")
	outputfile:write("Name: \"english\"; MessagesFile: \"compiler:Default.isl\"\n")

	outputfile:write("\n[Files]\n")

	if settings.proxy then
		local proxdirpath = postmake.output() .. "/innosetup"
		local proxyfilepath = proxdirpath .. "/" .. postmake.appname() .. ".exe"
		local proxyscriptfilepath = proxdirpath .. "/main.lua"

		postmake.os.mkdirall(proxdirpath)

		local proxyfile = io.open(proxyscriptfilepath, "w")
		if proxyfile == nil then
			print("unable to open file '" .. proxyfile .. "'")
			os.exit(1)
		end

		proxyfile:write("print(\"hello world\")")

		postmake.compile.luaprogram(proxyfilepath, "windows")

		local destdir = util.postmakepathtoinnoapppath(
			postmake.path.getparent(settings
				.proxy.path))

		outputfile:write("Source: \"" ..
			proxyfilepath ..
			"\"; DestDir: \"" .. destdir
			.. "\";\n")

		outputfile:write("Source: \"" ..
			proxyfilepath ..
			"\"; DestDir: \"" .. destdir
			.. "\";\n")

		proxyfile:close()
	end

	for inputval, output in pairs(config.files) do
		local input = inputval.string

		local reltoinnofile = input
		local newout = util.getdir(util.postmakepathtoinnoapppath(output))
		outputfile:write("Source: \"" .. reltoinnofile .. "\"; DestDir: \"" .. newout .. "\";\n")
	end

	outputfile:write("\n[Tasks]\n")
	for _, flag in ipairs(config.flags) do
		outputfile:write("Name: " ..
			util.flagnametovarable(flag.flagname()) .. "; Description: \"" .. flag.flagname() .. "\"\n")
	end

	makecodesecion(outputfile, config)

	local hasrunsection = #config.installcmds ~= 0 or settings.LaunchProgram ~= nil
	local hasuninstallsection = #config.uninstallcmds ~= 0

	if hasrunsection then
		outputfile:write("\n[Run]\n")
		if settings.LaunchProgram ~= nil then
			local torun = util.postmakepathtoinnoapppath(settings.LaunchProgram)

			outputfile:write("Filename: \"" .. torun ..
				"\"; Description: \"{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}\"; Flags: nowait postinstall skipifsilent\n")
		end

		for _, cmd in ipairs(config.installcmds) do
			outputfile:write("Filename: \"" ..
				util.postmakepathtoinnoapppathcmd(cmd.cmd()) .. "\"; Parameters: ")
			for _, item in ipairs(cmd.pars()) do
				outputfile:write("\"" .. util.postmakepathtoinnoapppathcmd(item) .. "\"")
			end
			outputfile:write("\n")
		end
	end

	if hasuninstallsection then
		outputfile:write("\n[UninstallRun]\n")
		for _, cmd in ipairs(config.uninstallcmds) do
			outputfile:write("Filename: \"" ..
				util.postmakepathtoinnoapppathcmd(cmd.cmd()) .. "\"; Parameters: ")
			for _, item in ipairs(cmd.pars()) do
				outputfile:write("\"" .. util.postmakepathtoinnoapppathcmd(item) .. "\"")
			end
			outputfile:write("\n")
		end
	end
	outputfile:close()
end

return build
